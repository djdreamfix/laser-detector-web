<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>OBD Analyzer</title>
  <style>
    :root{
      --bg:#f9f9fb; --card:#ffffff; --text:#111; --muted:#6b7280; --border:#e5e7eb;
      --accent:#007aff; --badge:#eef2ff;
    }
    *{box-sizing:border-box}
    html,body{margin:0;padding:0;background:var(--bg);color:var(--text);
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Noto Sans","Helvetica Neue",Arial,sans-serif;}
    header{position:sticky;top:0;z-index:20;background:var(--card);border-bottom:1px solid var(--border);
      padding:14px 16px;text-align:center;font-weight:600;font-size:18px}
    main{padding:16px;max-width:760px;margin:0 auto}
    .card{background:var(--card);border:1px solid var(--border);border-radius:16px;padding:16px;
      box-shadow:0 2px 10px rgba(0,0,0,0.04);margin-bottom:16px}
    .title{font-weight:600;font-size:16px;margin-bottom:8px}
    .subtitle{font-size:13px;color:var(--muted);margin-top:4px}
    .controls{display:flex;gap:8px;flex-wrap:wrap}
    .btn{padding:12px 14px;border-radius:12px;border:none;background:var(--accent);color:#fff;font-weight:700;cursor:pointer}
    .btn.secondary{background:#fff;color:var(--accent);border:1px solid var(--accent)}
    .small{font-size:12px;color:var(--muted)}
    .kv{display:grid;grid-template-columns:180px 1fr;gap:8px 12px}
    .badge{display:inline-block;padding:4px 8px;border-radius:8px;background:var(--badge)}
    .divider{height:1px;background:var(--border);margin:12px 0}
    .pill{display:inline-block;padding:4px 8px;border-radius:20px;background:#eef2ff;margin:2px 6px 0 0}
    .hidden{display:none !important}
    pre{white-space:pre-wrap;word-break:break-word}

    /* crop container */
    #cropContainer {
      position: relative;
      max-height: 80vh;
      overflow: auto;
      padding: 12px;
      background: #fff;
      border-radius: 12px;
      border: 1px solid var(--border);
      margin-bottom: 16px;
    }
    #cropContainer img {
      max-width: 100%;
      max-height: 70vh;
      object-fit: contain;
      border-radius: 12px;
      display: block;
      margin: 0 auto;
      user-select: none;
      -webkit-user-drag: none;
      touch-action: none;
    }
    #cropContainer canvas {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
      z-index: 10;
    }

    @media (max-width:768px){
      .btn{padding:12px 12px}
    }
  </style>

  <!-- Tesseract -->
  <script src="https://unpkg.com/tesseract.js@v5.0.3/dist/tesseract.min.js"></script>
</head>
<body>
  <header>OBD Analyzer</header>
  <main>
    <div class="card">
      <div class="title">–î–æ–¥–∞–π —Ñ–æ—Ç–æ –µ–∫—Ä–∞–Ω—É —Å–∫–∞–Ω–µ—Ä–∞</div>
      <div class="subtitle">OCR ‚Üí –ø–∞—Ä—Å–∏–Ω–≥ (V519) ‚Üí –ø–æ—Ä–∞–¥–∏ ‚Üí –ª–æ–∫–∞–ª—å–Ω–∞ –±–∞–∑–∞ DTC</div>

      <div class="controls" style="margin-top:10px">
        <input id="filePicker" type="file" accept="image/*" style="display:none" />
        <button id="btnPick" class="btn">üìÅ –î–æ–¥–∞—Ç–∏ —Ñ–æ—Ç–æ</button>
        <button id="btnOpenCamera" class="btn secondary">–í–∏–∫–æ—Ä–∏—Å—Ç–∞—Ç–∏ –∫–∞–º–µ—Ä—É</button>
        <button id="btnCapture" class="btn secondary hidden">–ó–∞—Ö–æ–ø–∏—Ç–∏ –∫–∞–¥—Ä</button>
        <button id="btnCrop" class="btn secondary hidden">–û–±—Ä—ñ–∑–∞—Ç–∏</button>
        <button id="btnStopCamera" class="btn secondary hidden">–ó—É–ø–∏–Ω–∏—Ç–∏ –∫–∞–º–µ—Ä—É</button>
        <button id="useDemo" class="btn secondary">–°–ø—Ä–æ–±—É–≤–∞—Ç–∏ –¥–µ–º–æ</button>
      </div>

      <div class="small" style="margin-top:8px">–ü–æ—Ä–∞–¥–∞: —Ñ–æ—Ç–æ —Ñ—Ä–æ–Ω—Ç–∞–ª—å–Ω–æ, –±–µ–∑ –≤—ñ–¥–±–ª–∏—Å–∫—ñ–≤; –ø—Ä–∏ –ø–æ—Ç—Ä–µ–±—ñ –ø—ñ–¥–≤–∏—â—É–π –∫–æ–Ω—Ç—Ä–∞—Å—Ç.</div>

      <div id="cropContainer" class="hidden" style="margin-top:12px"></div>
      <canvas id="previewCanvas" class="hidden"></canvas>
      <video id="video" autoplay playsinline class="hidden" style="margin-top:12px; width:100%; border-radius:12px;"></video>
    </div>

    <div class="card" id="resultCard">
      <div class="title">–†–µ–∑—É–ª—å—Ç–∞—Ç</div>
      <div class="subtitle" id="statusText">–ì–æ—Ç–æ–≤–æ</div>
      <div id="quickSummary" style="margin-top:8px"></div>
      <div class="divider"></div>
      <div class="kv" id="kv"></div>
      <div class="divider"></div>
      <div class="title">–ü–æ—Ä–∞–¥–∏</div>
      <ul id="advice" style="list-style:none;padding:0;margin:8px 0"></ul>
    </div>

    <div class="card">
      <div class="title">–ì—Ä–∞—Ñ—ñ–∫–∏ (–æ—Å—Ç–∞–Ω–Ω—ñ –¥–∞–Ω—ñ)</div>
      <div class="subtitle">RPM, ECT, MAP, MAF, TPS</div>
      <canvas id="chartRPM"></canvas>
      <canvas id="chartECT" style="margin-top:10px"></canvas>
      <canvas id="chartMAP" style="margin-top:10px"></canvas>
      <canvas id="chartMAF" style="margin-top:10px"></canvas>
      <canvas id="chartTPS" style="margin-top:10px"></canvas>
    </div>

    <div class="card">
      <div class="title">–õ–æ–∫–∞–ª—å–Ω–∞ –±–∞–∑–∞ DTC</div>
      <div class="subtitle">–ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –ø–æ–ø–æ–≤–Ω—é—î—Ç—å—Å—è –ø—Ä–∏ –∑–Ω–∞—Ö–æ–¥–∂–µ–Ω–Ω—ñ –Ω–æ–≤–∏—Ö –∫–æ–¥—ñ–≤</div>
      <div class="kv" id="dtcBaseView"></div>
      <div class="controls" style="margin-top:8px">
        <button id="downloadDB" class="btn secondary">–ï–∫—Å–ø–æ—Ä—Ç –±–∞–∑–∏ (JSON)</button>
        <input id="importFile" type="file" accept="application/json" class="hidden" />
        <button id="importBtn" class="btn secondary">–Ü–º–ø–æ—Ä—Ç –±–∞–∑–∏</button>
      </div>
    </div>
  </main>

  <script>
  /* ========= Globals ========= */
  let db;
  let cropStartX = null, cropStartY = null, cropEndX = null, cropEndY = null;
  let tempImgEl = null;
  let cameraStream = null;

  const filePicker = document.getElementById('filePicker');
  const btnPick = document.getElementById('btnPick');
  const btnOpenCamera = document.getElementById('btnOpenCamera');
  const btnCapture = document.getElementById('btnCapture');
  const btnStopCamera = document.getElementById('btnStopCamera');
  const btnCrop = document.getElementById('btnCrop');
  const btnUseDemo = document.getElementById('useDemo');
  const previewCanvas = document.getElementById('previewCanvas');
  const videoEl = document.getElementById('video');

  const statusText = document.getElementById('statusText');
  const kvEl = document.getElementById('kv');
  const adviceEl = document.getElementById('advice');
  const dtcBaseView = document.getElementById('dtcBaseView');
  const downloadDB = document.getElementById('downloadDB');
  const importFile = document.getElementById('importFile');
  const importBtn = document.getElementById('importBtn');
  const quickSummary = document.getElementById('quickSummary');

  /* ========= IndexedDB ========= */
  function openDB() {
    return new Promise((resolve, reject) => {
      const req = indexedDB.open('obd_app_db', 3);
      req.onupgradeneeded = (e) => {
        db = e.target.result;
        if (!db.objectStoreNames.contains('dtc')) db.createObjectStore('dtc', { keyPath: 'code' });
        if (!db.objectStoreNames.contains('series')) db.createObjectStore('series', { keyPath: 'id' });
        if (!db.objectStoreNames.contains('meta')) db.createObjectStore('meta', { keyPath: 'key' });
      };
      req.onsuccess = (e) => { db = e.target.result; resolve(db); };
      req.onerror = (e) => reject(e);
    });
  }
  async function openDBIfNeeded(){ if(!db) await openDB(); }
  async function dbPut(store, obj){
    await openDBIfNeeded();
    return new Promise((resolve,reject)=>{
      const tx = db.transaction(store, 'readwrite');
      tx.objectStore(store).put(obj);
      tx.oncomplete=()=>resolve(true);
      tx.onerror=(e)=>reject(e);
    });
  }
  async function dbGet(store, key){
    await openDBIfNeeded();
    return new Promise((resolve,reject)=>{
      const tx = db.transaction(store, 'readonly');
      const req = tx.objectStore(store).get(key);
      req.onsuccess=()=>resolve(req.result);
      req.onerror=(e)=>reject(e);
    });
  }
  async function dbGetAll(store){
    await openDBIfNeeded();
    return new Promise((resolve,reject)=>{
      const tx = db.transaction(store, 'readonly');
      const req = tx.objectStore(store).getAll();
      req.onsuccess=()=>resolve(req.result||[]);
      req.onerror=(e)=>reject(e);
    });
  }
  async function dbDeleteAll(store){
    await openDBIfNeeded();
    return new Promise((resolve,reject)=>{
      const tx=db.transaction(store,'readwrite');
      const req=tx.objectStore(store).clear();
      req.onsuccess=()=>resolve(true);
      req.onerror=(e)=>reject(e);
    });
  }

  /* ========= Seed families ========= */
  async function seedFamilies(){
    const families = [
      { code:'P03xx', name:'–ü—Ä–æ–ø—É—Å–∫–∏ –∑–∞–ø–∞–ª—é–≤–∞–Ω–Ω—è', desc:'–í–∏—è–≤–ª–µ–Ω—ñ –ø—Ä–æ–ø—É—Å–∫–∏ –∑–∞–ø–∞–ª—é–≤–∞–Ω–Ω—è.', actions:[
        "–ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ —Å–≤—ñ—á–∫–∏, –∫–æ—Ç—É—à–∫–∏, –¥—Ä–æ—Ç–∏.",
        "–ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ —Ñ–æ—Ä—Å—É–Ω–∫–∏ —Ç–∞ –∫–æ–º–ø—Ä–µ—Å—ñ—é.",
        "–ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –ø—ñ–¥—Å–º–æ–∫ –ø–æ–≤—ñ—Ç—Ä—è."
      ]},
      { code:'P0420', name:'–ï—Ñ–µ–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å –∫–∞—Ç–∞–ª—ñ–∑–∞—Ç–æ—Ä–∞ –Ω–∏–∑—å–∫–∞ (Bank 1)', desc:'–ö–∞—Ç–∞–ª—ñ–∑–∞—Ç–æ—Ä –Ω–µ–µ—Ñ–µ–∫—Ç–∏–≤–Ω–∏–π.', actions:[
        "–ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –≤–∏—Ç–æ–∫–∏ –≤–∏—Ö–ª–æ–ø—É –ø–µ—Ä–µ–¥ –∫–∞—Ç–æ–º.",
        "–û—Ü—ñ–Ω–∏—Ç–∏ –¥–∞—Ç—á–∏–∫–∏ O2 (–¥–æ/–ø—ñ—Å–ª—è –∫–∞—Ç—É).",
        "–ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ —Å—É–º—ñ—à."
      ]},
      { code:'P0171', name:'–ó–±—ñ–¥–Ω–µ–Ω–∞ —Å—É–º—ñ—à (Bank 1)', desc:'PCM –≤–∏—è–≤–∏–≤ –∑–±—ñ–¥–Ω–µ–Ω—É —Å—É–º—ñ—à.', actions:[
        "–ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –ø—ñ–¥—Å–º–æ–∫ –ø–æ–≤—ñ—Ç—Ä—è, –≤–∞–∫—É—É–º–Ω—ñ —à–ª–∞–Ω–≥–∏.",
        "–ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ MAF/MAP.",
        "–ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ —Ç–∏—Å–∫ –ø–∞–ª–∏–≤–∞."
      ]},
      { code:'P0103', name:'MAF ‚Äî –≤–∏—Å–æ–∫–∏–π —Ä—ñ–≤–µ–Ω—å —Å–∏–≥–Ω–∞–ª—É', desc:'–í–∏—Å–æ–∫–∏–π —Å–∏–≥–Ω–∞–ª –∑ MAF (High input).', actions:[
        "–û–≥–ª—è–Ω—É—Ç–∏ –ø—Ä–æ–≤–æ–¥–∫—É MAF.",
        "–û—á–∏—Å—Ç–∏—Ç–∏/–∑–∞–º—ñ–Ω–∏—Ç–∏ MAF.",
        "–ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –≥–µ—Ä–º–µ—Ç–∏—á–Ω—ñ—Å—Ç—å –≤–ø—É—Å–∫—É."
      ]}
    ];
    for (const f of families) await dbPut('dtc', f);
  }

  /* ========= Init ========= */
  document.addEventListener('DOMContentLoaded', async ()=>{
    await openDB();
    const seeded = await dbGet('meta','seeded');
    if(!seeded){ await seedFamilies(); await dbPut('meta',{key:'seeded', value:true}); }
    await renderDTCBase();
    await refreshCharts();
  });

  /* ========= Utils ========= */
  function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }
  function dedupe(arr){ const s=new Set(); const out=[]; for(const x of arr){ const k=String(x||'').trim(); if(!s.has(k)){ s.add(k); out.push(x); } } return out; }

  /* ========= OCR and parsing ========= */
  async function runOCRFromCanvas(canvas){
    try {
      statusText.textContent = 'üîé –í–∏–∫–æ–Ω—É—î—Ç—å—Å—è OCR‚Ä¶';
      const blob = await new Promise(res => canvas.toBlob(res, 'image/png'));
      const { data } = await Tesseract.recognize(blob, 'eng+rus', { logger: m => console.log('Tesseract', m) });
      statusText.textContent = '‚úÖ OCR –∑–∞–≤–µ—Ä—à–µ–Ω–æ';
      return data?.text ?? '';
    } catch (e){
      console.error('OCR error', e);
      statusText.textContent = '‚ùå –ü–æ–º–∏–ª–∫–∞ OCR';
      throw e;
    }
  }

  async function parseV519(text){
    const out = {};
    const T = String(text || '').replace(/\s+/g,' ').trim();
    out.OCRText = T;

    const dtc = [...T.matchAll(/\b([PBCU]\d{4})\b/gi)].map(m=>m[1].toUpperCase());
    if (dtc.length) out.–ö–æ–¥–∏–ü–æ–º–∏–ª–æ–∫ = dtc;

    const rpm = T.match(/\bRPM\b[:\s]*(-?\d{2,5})/i);
    if (rpm) out.–û–±–æ—Ä–æ—Ç–∏ = +rpm[1];

    const ect = T.match(/\b(ECT|ETC|Coolant)\s*[:\s]*(-?\d{1,5})/i);
    if (ect){ const val=+ect[2]; if(val>-40 && val<150) out.–¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞–û–ñ = val; }

    const map = T.match(/\bMAP\b.*?[:\s]*(-?\d{1,3}(?:\.\d{1,3})?)/i);
    if (map) out.–¢–∏—Å–∫MAP = +(map[1]);

    const maf = T.match(/\bMAF\b.*?[:\s]*(-?\d{1,3}(?:\.\d{1,3})?)\s?g\/s/i);
    if (maf) out.–ú–∞—Å–æ–≤–∞–í–∏—Ç—Ä–∞—Ç–∞–ü–æ–≤—ñ—Ç—Ä—è_gs = +maf[1];

    const tps = T.match(/\b(TPS|Throttle)\s*`\(?%?\)`?[:\s]*(-?\d{1,3}(?:\.\d+)?)/i);
    if (tps) out.–ü–æ–ª–æ–∂–µ–Ω–Ω—è–î—Ä–æ—Å–µ–ª—è–í—ñ–¥—Å–æ—Ç–æ–∫ = +tps[2];

    const volt = T.match(/\b(Battery|Voltage)\b[:\s]*([0-9]{1,2}\.?[0-9])\s?V\b/i);
    if (volt) out.–ù–∞–ø—Ä—É–≥–∞–ê–ö–ë = +volt[2];

    const mil = T.match(/\b(MIL|Check\s*Engine)\b.*\b(ON|OFF)\b/i);
    if (mil) out.–ú–Ü–õ = mil[2].toUpperCase();

    return out;
  }

  /* ========= Crop flow ========= */
  function startCropperFromUrl(url) {
    const container = document.getElementById('cropContainer');
    container.innerHTML = '';
    container.classList.remove('hidden');
    container.style.position = 'relative';

    if (tempImgEl) {
      try { tempImgEl.remove(); } catch(e){}
      tempImgEl = null;
    }

    tempImgEl = document.createElement('img');
    tempImgEl.src = url;
    tempImgEl.className = 'crop-target';
    tempImgEl.style.maxWidth = '100%';
    tempImgEl.style.maxHeight = '70vh';
    tempImgEl.style.display = 'block';
    tempImgEl.style.margin = '0 auto';
    tempImgEl.style.touchAction = 'none';

    container.appendChild(tempImgEl);

    tempImgEl.onload = () => {
      previewCanvas.width = tempImgEl.naturalWidth;
      previewCanvas.height = tempImgEl.naturalHeight;
      previewCanvas.style.position = 'absolute';
      previewCanvas.style.top = '0';
      previewCanvas.style.left = '0';
      previewCanvas.style.zIndex = '10';
      previewCanvas.classList.remove('hidden');

      const rect = tempImgEl.getBoundingClientRect();
      previewCanvas.style.width = rect.width + 'px';
      previewCanvas.style.height = rect.height + 'px';

      container.appendChild(previewCanvas);

      btnCrop.classList.remove('hidden');
      statusText.textContent = '–í–∏–¥—ñ–ª—ñ—Ç—å –æ–±–ª–∞—Å—Ç—å –¥–ª—è –æ–±—Ä—ñ–∑–∫–∏ (–ø–µ—Ä–µ—Ç—è–≥–Ω—ñ—Ç—å –ø–∞–ª—å—Ü–µ–º –∞–±–æ –º–∏—à–æ—é)';

      setupCropSelection(tempImgEl, previewCanvas);
    };
  }

  function setupCropSelection(img, canvas) {
    let isCropping = false;
    let startX = null, startY = null, endX = null, endY = null;
    const ctx = canvas.getContext('2d');

    function getPosFromEvent(e) {
      const rect = img.getBoundingClientRect();
      const clientX = (e.touches && e.touches[0]) ? e.touches[0].clientX : e.clientX;
      const clientY = (e.touches && e.touches[0]) ? e.touches[0].clientY : e.clientY;
      const x = ((clientX - rect.left) / rect.width) * img.naturalWidth;
      const y = ((clientY - rect.top) / rect.height) * img.naturalHeight;
      return { x: Math.max(0, Math.min(img.naturalWidth, x)), y: Math.max(0, Math.min(img.naturalHeight, y)) };
    }

    function drawOverlay() {
      ctx.clearRect(0,0,canvas.width, canvas.height);
      if (startX == null || endX == null) return;
      const x = Math.min(startX, endX);
      const y = Math.min(startY, endY);
      const w = Math.abs(endX - startX);
      const h = Math.abs(endY - startY);
      ctx.fillStyle = 'rgba(0,0,0,0.45)';
      ctx.fillRect(0,0,canvas.width, canvas.height);
      ctx.clearRect(x,y,w,h);
      ctx.strokeStyle = 'red';
      ctx.lineWidth = Math.max(2, Math.round(canvas.width / 400));
      ctx.strokeRect(x,y,w,h);
    }

    function start(e) {
      isCropping = true;
      const pos = getPosFromEvent(e);
      startX = pos.x; startY = pos.y;
      endX = pos.x; endY = pos.y;
      cropStartX = startX; cropStartY = startY; cropEndX = endX; cropEndY = endY;
      drawOverlay();
      e.preventDefault();
    }

    function move(e) {
      if (!isCropping) return;
      const pos = getPosFromEvent(e);
      endX = pos.x; endY = pos.y;
      cropStartX = Math.min(startX, endX);
      cropStartY = Math.min(startY, endY);
      cropEndX = Math.max(startX, endX);
      cropEndY = Math.max(startY, endY);
      drawOverlay();
      e.preventDefault();
    }

    function end(e) {
      isCropping = false;
      if (Math.abs(endX - startX) < 4) { endX = startX + 4; }
      if (Math.abs(endY - startY) < 4) { endY = startY + 4; }
      cropStartX = Math.min(startX, endX);
      cropStartY = Math.min(startY, endY);
      cropEndX = Math.max(startX, endX);
      cropEndY = Math.max(startY, endY);
    }

    img.addEventListener('mousedown', start);
    window.addEventListener('mousemove', move);
    window.addEventListener('mouseup', end);
    img.addEventListener('touchstart', start, { passive: false });
    window.addEventListener('touchmove', move, { passive: false });
    window.addEventListener('touchend', end);
  }

  /* ========= Crop action ========= */
  btnCrop.addEventListener('click', async () => {
    if (!tempImgEl || cropStartX == null || cropStartY == null || cropEndX == null || cropEndY == null) {
      statusText.textContent = '–°–ø–æ—á–∞—Ç–∫—É –≤–∏–¥—ñ–ª—ñ—Ç—å –æ–±–ª–∞—Å—Ç—å!';
      return;
    }

    const width = Math.max(1, Math.round(cropEndX - cropStartX));
    const height = Math.max(1, Math.round(cropEndY - cropStartY));

    const croppedCanvas = document.createElement('canvas');
    croppedCanvas.width = width;
    croppedCanvas.height = height;
    const ctx = croppedCanvas.getContext('2d');

    ctx.drawImage(
      tempImgEl,
      Math.round(cropStartX), Math.round(cropStartY), width, height,
      0, 0, width, height
    );

    previewCanvas.width = width;
    previewCanvas.height = height;
    previewCanvas.style.position = 'relative';
    previewCanvas.style.width = '100%';
    previewCanvas.style.height = 'auto';
    previewCanvas.getContext('2d').drawImage(croppedCanvas, 0, 0);
    previewCanvas.classList.remove('hidden');

    try { tempImgEl.remove(); } catch(e){}
    tempImgEl = null;
    document.getElementById('cropContainer').classList.add('hidden');
    btnCrop.classList.add('hidden');
    statusText.textContent = '–û–±—Ä—ñ–∑–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –û–±—Ä–æ–±–ª—è—î–º–æ OCR...';

    try {
      const text = await runOCRFromCanvas(previewCanvas);
      const parsed = await parseV519(text);
      await ensureDTCs(parsed.–ö–æ–¥–∏–ü–æ–º–∏–ª–æ–∫);
      const tips = await buildAdvice(parsed);
      await saveSeriesEntry(parsed);
      renderResult(parsed, tips);
      await renderDTCBase();
      await refreshCharts();
    } catch (e) {
      console.error(e);
      statusText.textContent = '–ü–æ–º–∏–ª–∫–∞ –æ–±—Ä–æ–±–∫–∏ OCR';
    }
  });

  /* ========= Camera flow ========= */
  btnPick.addEventListener('click', ()=> filePicker.click());

  filePicker.addEventListener('change', async (e)=>{
    const f = e.target.files && e.target.files[0];
    if (!f) return;
    const url = URL.createObjectURL(f);
    startCropperFromUrl(url);
  });

  btnOpenCamera.addEventListener('click', async ()=>{
    try {
      if (cameraStream) stopCamera();
      cameraStream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:'environment' }, audio:false });
      videoEl.srcObject = cameraStream;
      videoEl.classList.remove('hidden');
      btnCapture.classList.remove('hidden');
      btnStopCamera.classList.remove('hidden');
      statusText.textContent = '–ö–∞–º–µ—Ä–∞ —É–≤—ñ–º–∫–Ω–µ–Ω–∞. –ù–∞–≤–µ–¥–∏ –Ω–∞ –µ–∫—Ä–∞–Ω —ñ –Ω–∞—Ç–∏—Å–Ω–∏ –ó–∞—Ö–æ–ø–∏—Ç–∏ –∫–∞–¥—Ä';
    } catch (e){
      console.error('camera error', e);
      statusText.textContent = '–ù–µ –≤–¥–∞–ª–æ—Å—è –≤—ñ–¥–∫—Ä–∏—Ç–∏ –∫–∞–º–µ—Ä—É';
    }
  });

  btnStopCamera.addEventListener('click', ()=> stopCamera());

  function stopCamera(){
    if (!cameraStream) return;
    cameraStream.getTracks().forEach(t=>t.stop());
    cameraStream = null;
    videoEl.pause();
    videoEl.srcObject = null;
    videoEl.classList.add('hidden');
    btnCapture.classList.add('hidden');
    btnStopCamera.classList.add('hidden');
    statusText.textContent = '–ö–∞–º–µ—Ä–∞ –∑—É–ø–∏–Ω–µ–Ω–∞';
  }

  btnCapture.addEventListener('click', ()=>{
    if (!videoEl || videoEl.readyState < 2) { statusText.textContent='–ö–∞–¥—Ä –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∏–π'; return; }
    const tmp = document.createElement('canvas');
    tmp.width = videoEl.videoWidth;
    tmp.height = videoEl.videoHeight;
    tmp.getContext('2d').drawImage(videoEl,0,0,tmp.width,tmp.height);
    stopCamera();
    const url = tmp.toDataURL('image/png');
    startCropperFromUrl(url);
  });

  /* ========= Demo ========= */
  btnUseDemo.addEventListener('click', async ()=>{
    const demoText = `
      Data Stream
      DTC.CNT: 1
      DTCFRZF: P0012
      FUELSYS1: CL
      LOAD PCT(%): 68.2
      ETC(¬∞C): 90
      RPM: 760
      MAP(kPa): 45
      MAF(g/s): 3.2
      TPS(%): 12.0
      O2 B1 S1(V): 0.78
      SHRTFT1(%): 2.3
    `;
    statusText.textContent = '–ê–Ω–∞–ª—ñ–∑—É—é –¥–µ–º–æ –¥–∞–Ω—ñ‚Ä¶';
    const parsed = await parseV519(demoText);
    const tips = await buildAdvice(parsed);
    await saveSeriesEntry(parsed);
    renderResult(parsed, tips);
    await renderDTCBase();
    await refreshCharts();
  });

  /* ========= DTC fetch/ensure ========= */
  async function ensureDTCs(codes){
    if(!codes || !codes.length) return;
    for(const code of codes){
      const existing = await dbGet('dtc', code);
      if (existing) continue;
      try {
        const info = await fetchDTCViaProxy(code);
        const record = {
          code,
          name: info.name || '–ù–µ–≤—ñ–¥–æ–º–∏–π –∫–æ–¥',
          desc: info.desc || '',
          actions: (info.actions && info.actions.length) ? info.actions : [
            "–ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –ø—Ä–æ–≤–æ–¥–∫—É/—Ä–æ–∑'—î–º.",
            "–ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –∑–Ω–∞—á–µ–Ω–Ω—è —Å–µ–Ω—Å–æ—Ä—ñ–≤ —É Data Stream.",
            "–ü–µ—Ä–µ–≥–ª—è–Ω—É—Ç–∏ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—ó –≤–∏—Ä–æ–±–Ω–∏–∫–∞."
          ]
        };
        await dbPut('dtc', record);
      } catch(e){ console.warn('fetch DTC failed', e); }
    }
  }

  async function fetchDTCViaProxy(code){
    const target = `https://obd.avto.pro/${code.toLowerCase()}/`;
    const url = `https://api.allorigins.win/get?url=${encodeURIComponent(target)}`;
    const res = await fetch(url);
    if (!res.ok) throw new Error('–ü—Ä–æ–∫—Å—ñ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∏–π');
    const data = await res.json();
    const html = data.contents || '';
    return extractFromHTML(html);
  }
  function extractFromHTML(html){
    const name = extractBetween(html,'<h1','</h1>').replace(/<[^>]+>/g,'').trim() || '';
    let desc = '';
    const metaMatch = html.match(/<meta[^>]+name=["']description["'][^>]+content=["']([^"']+)["'][^>]*>/i);
    if (metaMatch) desc = metaMatch[1].trim();
    const actions = [];
    const items = html.match(/<li[^>]*>(.*?)<\/li>/gi) || [];
    items.forEach(li=>{
      const txt = li.replace(/<[^>]+>/g,'').trim();
      if (/–ø—Ä–∏—á–∏–Ω|—Å–∏–ºptom|—Ä–µ—à–µ–Ω–∏|solution|cause|symptom|repair|diagnos|—Ä–µ–º–æ–Ω—Ç|—Å–æ–≤–µ—Ç|—Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü/i.test(txt)) actions.push(txt);
    });
    return { name, desc, actions };
  }
  function extractBetween(html, startTag, endTag){
    const start = html.indexOf(startTag);
    if (start === -1) return '';
    const end = html.indexOf(endTag, start);
    if (end === -1) return '';
    return html.substring(start, end + endTag.length);
  }

  /* ========= Advice builder ========= */
  async function lookupDTC(code){
    const rec = await dbGet('dtc', code);
    if (rec) return rec;
    const fam = code.replace(/(\d)\d{2}$/, '$1xx');
    const famRec = await dbGet('dtc', fam);
    if (famRec) return famRec;
    return { code, name:"–ù–µ–≤—ñ–¥–æ–º–∏–π –∫–æ–¥", desc:"–ù–µ–º–∞—î –∑–∞–ø–∏—Å—É –≤ –±–∞–∑—ñ.", actions:[
      "–ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ freeze frame —Ç–∞ —Å—É–ø—É—Ç–Ω—ñ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏.",
      "–ó—á–∏—Ç–∞—Ç–∏ –¥–æ–¥–∞—Ç–∫–æ–≤—ñ –∫–æ–¥–∏ —ñ on-board –º–æ–Ω—ñ—Ç–æ—Ä–∏.",
      "–ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –∂–∏–≤–ª–µ–Ω–Ω—è, –º–∞—Å—É, –ø—Ä–æ–≤–æ–¥–∫—É."
    ]};
  }

  async function buildAdvice(data){
    const tips = [];
    if (!data) return ['–ü—Ä–æ–±–ª–µ–º –Ω–µ –≤–∏—è–≤–ª–µ–Ω–æ –∞–±–æ –ø–æ—Ç—Ä—ñ–±–Ω—ñ –¥–æ–¥–∞—Ç–∫–æ–≤—ñ –¥–∞–Ω—ñ.'];

    const dtcs = data.–ö–æ–¥–∏–ü–æ–º–∏–ª–æ–∫ || [];
    if (dtcs && dtcs.length){
      for(const code of dtcs){
        const info = await lookupDTC(code);
        tips.push(`–ö–æ–¥ ${code}: ${info.name}. ${info.desc || ''}`);
        (info.actions || []).forEach(a => tips.push("‚Ä¢ " + a));
      }
    }

    if (data.–ú–Ü–õ === 'ON') tips.push("MIL: ON ‚Äî —É—Å—É–Ω—å –∞–∫—Ç–∏–≤–Ω—ñ DTC —Ç–∞ –∑–∞–≤–µ—Ä—à —Ü–∏–∫–ª —ó–∑–¥–∏.");

    if (typeof data.–ù–∞–ø—Ä—É–≥–∞–ê–ö–ë === 'number'){
      if (data.–ù–∞–ø—Ä—É–≥–∞–ê–ö–ë < 11.8) tips.push("–ù–∏–∑—å–∫–∞ –Ω–∞–ø—Ä—É–≥–∞ –ê–ö–ë: –ø–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –∞–∫—É–º—É–ª—è—Ç–æ—Ä —Ç–∞ –∑–∞—Ä—è–¥ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞.");
      else if (data.–ù–∞–ø—Ä—É–≥–∞–ê–ö–ë > 14.8) tips.push("–í–∏—Å–æ–∫–∞ –Ω–∞–ø—Ä—É–≥–∞ –ê–ö–ë: –º–æ–∂–ª–∏–≤–∏–π –ø–µ—Ä–µ–∑–∞—Ä—è–¥ ‚Äî –ø–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ —Ä–µ–≥—É–ª—è—Ç–æ—Ä.");
    }

    if (typeof data.–¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞–û–ñ === 'number'){
      if (data.–¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞–û–ñ > 115) tips.push("–ü–µ—Ä–µ–≥—Ä—ñ–≤: –ø–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ —Ç–µ—Ä–º–æ—Å—Ç–∞—Ç, –≤–µ–Ω—Ç–∏–ª—è—Ç–æ—Ä–∏, —Ä—ñ–≤–µ–Ω—å –∞–Ω—Ç–∏—Ñ—Ä–∏–∑—É.");
    }

    return dedupe(tips);
  }

  /* ========= Series & Charts ========= */
  async function saveSeriesEntry(parsed){
    const entry = { id: crypto.randomUUID(), ts: Date.now(), screenType: 'data_stream', data: parsed };
    await dbPut('series', entry);
    return entry;
  }
  async function getRecentSeries(limit=60){
    const all = await dbGetAll('series');
    return all.slice(-limit);
  }
  function plotLine(canvasEl, values, color='#007aff', label=''){
    const cvs = canvasEl;
    const ctx = cvs.getContext('2d');
    const w = cvs.width = cvs.clientWidth || 600;
    const h = cvs.height = 160;
    ctx.clearRect(0,0,w,h);
    if (!values.length) {
      ctx.fillStyle = '#999'; ctx.font = '12px system-ui'; ctx.fillText('–ù–µ–º–∞—î –¥–∞–Ω–∏—Ö', 12, 24); return;
    }
    const min = Math.min(...values), max = Math.max(...values);
    const pad = 10;
    ctx.strokeStyle = '#e5e7eb';
    ctx.beginPath(); ctx.moveTo(pad, h - pad); ctx.lineTo(w - pad, h - pad); ctx.stroke();
    ctx.strokeStyle = color; ctx.lineWidth = 2; ctx.beginPath();
    values.forEach((v,i)=>{
      const x = pad + (i / Math.max(1, values.length - 1)) * (w - pad*2);
      const y = pad + (1 - (v - min) / Math.max(1, (max - min))) * (h - pad*2);
      if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    });
    ctx.stroke();
    ctx.fillStyle = '#6b7280'; ctx.font = '11px system-ui';
    ctx.fillText(`${label} min:${min.toFixed(2)} max:${max.toFixed(2)}`, 12, h - 8);
  }
  async function refreshCharts(){
    const series = await getRecentSeries(60);
    const rpmVals = series.map(s => s.data.–û–±–æ—Ä–æ—Ç–∏).filter(v => typeof v === 'number');
    const ectVals = series.map(s => s.data.–¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞–û–ñ).filter(v => typeof v === 'number');
    const mapVals = series.map(s => s.data.–¢–∏—Å–∫MAP).filter(v => typeof v === 'number');
    const mafVals = series.map(s => s.data.–ú–∞—Å–æ–≤–∞–í–∏—Ç—Ä–∞—Ç–∞–ü–æ–≤—ñ—Ç—Ä—è_gs).filter(v => typeof v === 'number');
    const tpsVals = series.map(s => s.data.–ü–æ–ª–æ–∂–µ–Ω–Ω—è–î—Ä–æ—Å–µ–ª—è–í—ñ–¥—Å–æ—Ç–æ–∫).filter(v => typeof v === 'number');
    plotLine(document.getElementById('chartRPM'), rpmVals, '#d946ef', 'RPM');
    plotLine(document.getElementById('chartECT'), ectVals, '#2563eb', 'ECT');
    plotLine(document.getElementById('chartMAP'), mapVals, '#10b981', 'MAP');
    plotLine(document.getElementById('chartMAF'), mafVals, '#f59e0b', 'MAF');
    plotLine(document.getElementById('chartTPS'), tpsVals, '#8b5cf6', 'TPS');
  }

  /* ========= Render ========= */
  function renderKV(obj){
    kvEl.innerHTML = '';
    const add = (k, v) => {
      const key = document.createElement('div'); key.textContent = k;
      const val = document.createElement('div');
      if (v && typeof v === 'object' && !Array.isArray(v)) {
        const sub = Object.entries(v).map(([kk,vv])=>`${kk}: ${vv}`).join(', ');
        val.innerHTML = `<span class="badge">${escapeHtml(sub)}</span>`;
      } else if (Array.isArray(v)) {
        val.innerHTML = `<span class="badge">${escapeHtml((v||[]).join(', '))}</span>`;
      } else {
        val.innerHTML = `<span class="badge">${escapeHtml(String(v))}</span>`;
      }
      kvEl.appendChild(key); kvEl.appendChild(val);
    };

    if (!obj || !Object.keys(obj).length) { add('–°—Ç–∞—Ç—É—Å','–ù–µ–º–∞—î —Ä–æ–∑–ø—ñ–∑–Ω–∞–Ω–∏—Ö –ø–æ–ª—ñ–≤'); return; }

    Object.entries(obj).forEach(([k,v])=>{
      if (k === 'OCRText') return;
      add(k, v);
    });

    if (obj.OCRText){
      const details = document.createElement('details');
      details.className = 'debug';
      const sum = document.createElement('summary'); sum.textContent = '–ü–æ–∫–∞–∑–∞—Ç–∏ —Å–∏—Ä–∏–π OCR‚Äë—Ç–µ–∫—Å—Ç';
      const pre = document.createElement('pre'); pre.textContent = obj.OCRText;
      details.appendChild(sum); details.appendChild(pre); kvEl.appendChild(details);
    }
  }

  function renderAdvice(arr){
    adviceEl.innerHTML = '';
    if (!arr || !arr.length){
      const li = document.createElement('li'); li.textContent = '–ü—Ä–æ–±–ª–µ–º –Ω–µ –≤–∏—è–≤–ª–µ–Ω–æ –∞–±–æ –ø–æ—Ç—Ä—ñ–±–Ω—ñ –¥–æ–¥–∞—Ç–∫–æ–≤—ñ –¥–∞–Ω—ñ.'; adviceEl.appendChild(li); return;
    }
    arr.forEach(x=>{ const li=document.createElement('li'); li.textContent = x; adviceEl.appendChild(li); });
  }

  function renderResult(parsed, tips){
    renderKV(parsed);
    renderAdvice(tips);
    quickSummary.innerHTML = '';
    statusText.textContent = '–ì–æ—Ç–æ–≤–æ';
    if (Array.isArray(parsed.–ö–æ–¥–∏–ü–æ–º–∏–ª–æ–∫) && parsed.–ö–æ–¥–∏–ü–æ–º–∏–ª–æ–∫.length){
      const pill = document.createElement('div'); pill.className='pill'; pill.textContent = `DTC: ${parsed.–ö–æ–¥–∏–ü–æ–º–∏–ª–æ–∫.join(', ')}`; quickSummary.appendChild(pill);
    }
    if (typeof parsed.–û–±–æ—Ä–æ—Ç–∏ === 'number'){ const pill=document.createElement('div'); pill.className='pill'; pill.textContent = `RPM: ${parsed.–û–±–æ—Ä–æ—Ç–∏}`; quickSummary.appendChild(pill); }
    if (typeof parsed.–¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞–û–ñ === 'number'){ const pill=document.createElement('div'); pill.className='pill'; pill.textContent = `ECT: ${parsed.–¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞–û–ñ}¬∞C`; quickSummary.appendChild(pill); }
  }

  /* ========= DTC base render & import/export ========= */
  async function renderDTCBase(){
    dtcBaseView.innerHTML = '';
    const all = await dbGetAll('dtc');
    const keys = all.map(x=>x.code).sort();
    if (!keys.length){
      const d1=document.createElement('div'); d1.textContent='‚Äî'; dtcBaseView.appendChild(d1);
      const d2=document.createElement('div'); d2.textContent='–ë–∞–∑–∞ –ø–æ—Ä–æ–∂–Ω—è'; dtcBaseView.appendChild(d2);
      return;
    }
    keys.slice(0,30).forEach(code=>{
      const rec = all.find(x=>x.code===code);
      const kEl=document.createElement('div'); kEl.textContent=code;
      const vEl=document.createElement('div'); vEl.innerHTML=`<span class="badge">${escapeHtml(rec.name||'')}</span> <div class="small">${escapeHtml(rec.desc||'')}</div>`;
      dtcBaseView.appendChild(kEl); dtcBaseView.appendChild(vEl);
    });
    if (keys.length>30){
      const mk=document.createElement('div'); mk.textContent='‚Ä¶'; dtcBaseView.appendChild(mk);
      const mv=document.createElement('div'); mv.textContent=`–ü–æ–∫–∞–∑–∞–Ω–æ 30 –∑ ${keys.length}`; dtcBaseView.appendChild(mv);
    }
  }

  downloadDB.addEventListener('click', async ()=>{
    const dtc = await dbGetAll('dtc'); const series = await dbGetAll('series');
    const payload = { dtc, series, exportedAt: new Date().toISOString() };
    const blob = new Blob([JSON.stringify(payload,null,2)], { type:'application/json' });
    const url = URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='obd_analyzer_db.json'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  });

  importBtn.addEventListener('click', ()=> importFile.click());
  importFile.addEventListener('change', async (e)=>{
    const f = e.target.files[0]; if(!f) return;
    const text = await f.text();
    try {
      const data = JSON.parse(text);
      await dbDeleteAll('dtc'); await dbDeleteAll('series');
      if (Array.isArray(data.dtc)) for (const rec of data.dtc) await dbPut('dtc', rec);
      if (Array.isArray(data.series)) for (const s of data.series) await dbPut('series', s);
      await renderDTCBase(); await refreshCharts();
      alert('–Ü–º–ø–æ—Ä—Ç –≤–∏–∫–æ–Ω–∞–Ω–æ');
    } catch(e){ alert('–ü–æ–º–∏–ª–∫–∞ —ñ–º–ø–æ—Ä—Ç—É'); }
  });

  /* ========= Helper small fixes ========= */
  async function ensureDTCsFlexible(parsed){
    const codes = parsed?.–ö–æ–¥–∏–ü–æ–º–∏–ª–æ–∫ || parsed?.–ö–æ–¥–∏ || parsed?.–ö–æ–¥—ã || [];
    await ensureDTCs(codes);
  }

  </script>
</body>
</html>