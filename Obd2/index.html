<!doctype html>
<html lang="uk">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>OBD2 OCR ‚Äî V519</title>

  <!-- Cropper + Tesseract -->
  <link href="https://unpkg.com/cropperjs/dist/cropper.min.css" rel="stylesheet"/>
  <script src="https://unpkg.com/cropperjs"></script>
  <script src="https://unpkg.com/tesseract.js@v5.0.3/dist/tesseract.min.js"></script>

  <style>
    /* iOS-like minimal UI */
    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial; padding: 16px; color:#222; background:#fff; }
    .controls { display:flex; gap:8px; flex-wrap:wrap; margin-bottom:12px; }
    .btn { background:#007aff; color:#fff; border:none; padding:8px 12px; border-radius:10px; cursor:pointer; font-weight:600; }
    .btn.secondary { background:#f1f3f5; color:#111; }
    #canvas { max-width:100%; border-radius:8px; display:block; margin-top:8px; background:#fafafa; }
    #statusText { margin-top:8px; color:#444; font-weight:500; min-height:20px; }

    /* kv display */
    #kv { max-width:760px; margin-top:12px; }
    .kv-row { padding:8px 12px; margin:6px 0; border:1px solid #e6e6e6; border-radius:10px; background:#fbfbfb; display:flex; gap:10px; align-items:flex-start; }
    .kv-key { font-weight:600; color:#222; min-width:120px; }
    .badge { display:inline-block; padding:6px 10px; background:#f1f3f5; border-radius:999px; color:#333; font-size:14px; }
    details.debug { margin-top:10px; border:1px solid #ddd; border-radius:10px; background:#fff; padding:8px; }
    details.debug summary { cursor:pointer; color:#007aff; font-weight:600; }
    details.debug pre { margin-top:8px; padding:8px; background:#f7f7f7; border-radius:8px; font-family: Menlo, SFMono-Regular, monospace; white-space:pre-wrap; word-break:break-word; }
    /* helper */
    .hidden { display:none !important; }
  </style>
</head>
<body>

  <h3>OBD2 V519 OCR</h3>

  <div class="controls">
    <button id="openCameraBtn" class="btn">–í—ñ–¥–∫—Ä–∏—Ç–∏ –∫–∞–º–µ—Ä—É</button>
    <button id="captureBtn" class="btn secondary hidden">–ó–∞—Ö–æ–ø–∏—Ç–∏ –∫–∞–¥—Ä</button>

    <input type="file" id="fileInput" accept="image/*" style="display:none">
    <button id="pickPhotoBtn" class="btn">üì∑ –î–æ–¥–∞—Ç–∏ —Ñ–æ—Ç–æ</button>

    <button id="cropBtn" class="btn secondary hidden">–û–±—Ä—ñ–∑–∞—Ç–∏</button>
    <button id="stopCameraBtn" class="btn secondary hidden">–ó—É–ø–∏–Ω–∏—Ç–∏ –∫–∞–º–µ—Ä—É</button>
  </div>

  <video id="video" autoplay playsinline class="hidden" style="max-width:90vw; border-radius:8px; background:#000"></video>
  <canvas id="canvas" class="hidden"></canvas>

  <div id="statusText">–ì–æ—Ç–æ–≤–æ</div>

  <div id="kv"></div>

  <script>
  /* ==================== parseV519 (–∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞, –∑–±–µ—Ä–µ–∂–µ–Ω–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞) ==================== */
  async function parseV519(text) {
    const out = {};
    const T = String(text || '').replace(/\s+/g,' ').trim();
    out.OCRText = T;

    // DTCs
    const dtc = [...T.matchAll(/\b([PBCU]\d{4})\b/gi)].map(m => m[1].toUpperCase());
    if (dtc.length) out.–ö–æ–¥–∏–ü–æ–º–∏–ª–æ–∫ = dtc;

    // Freeze Frame
    const frz = T.match(/\bDTCFRZE?F?\b[:\s]*([PBCU]\d{4})/i);
    if (frz) out.FreezeFrameDTC = frz[1].toUpperCase();

    // RPM
    const rpm = T.match(/\bRPM\b[:\s]*(-?\d{2,5})/i);
    if (rpm) out.–û–±–æ—Ä–æ—Ç–∏ = Number(rpm[1]);

    // Temperatures
    const ect = T.match(/\b(ECT|ETC|Coolant)\s*[:\s]*(-?\d{1,5})/i);
    if (ect) { const val=Number(ect[2]); if(val>-40 && val<150) out.–¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞–û–ñ = val; }

    const iat = T.match(/\b(IAT|Intake Air Temp)\s*[:\s]*(-?\d{1,5})/i);
    if (iat) { const val=Number(iat[2]); if(val>-40 && val<150) out.–¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞–í–ø—É—Å–∫—É = val; }

    const eot = T.match(/\b(EOT|Engine Oil Temp)\s*[:\s]*(-?\d{1,5})/i);
    if (eot) { const val=Number(eot[2]); if(val>-40 && val<180) out.–¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞–û–ª–∏–≤–∏ = val; }

    // Load / TPS / MAP / MAF
    const load = T.match(/\bLOAD[_\s]?PCT`\(?%?\)`?[:\s]*(-?\d{1,3}(?:\.\d+)?)/i);
    if (load) out.–ù–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è–í—ñ–¥—Å–æ—Ç–æ–∫ = Number(load[1]);

    const tps = T.match(/\b(TPS|Throttle)\s*`\(?%?\)`?[:\s]*(-?\d{1,3}(?:\.\d+)?)/i);
    if (tps) out.–ü–æ–ª–æ–∂–µ–Ω–Ω—è–î—Ä–æ—Å–µ–ª—è–í—ñ–¥—Å–æ—Ç–æ–∫ = Number(tps[2]);

    const map = T.match(/\bMAP\b.*?[:\s]*(-?\d{1,3}(?:\.\d{1,3})?)\s?(kPa|inHg)?/i);
    if (map) out.–¢–∏—Å–∫MAP = map[1] + (map[2] ? ' ' + map[2] : '');

    const maf = T.match(/\bMAF\b.*?[:\s]*(-?\d{1,3}(?:\.\d{1,3})?)\s?g\/s/i);
    if (maf) out.MAF_gs = Number(maf[1]);

    // Fuel system
    const fs1 = T.match(/\bFUELSYS[1!]\b[:\s]*(CL|OL|NA|OK|-?\d{1,3})/i);
    if (fs1) out.–ü–∞–ª–∏–≤–Ω–∞–°–∏—Å—Ç–µ–º–∞1 = fs1[1].toUpperCase();
    const fs2 = T.match(/\bFUELSYS[2?]\b[:\s]*(CL|OL|NA|OK|-?\d{1,3})/i);
    if (fs2) out.–ü–∞–ª–∏–≤–Ω–∞–°–∏—Å—Ç–µ–º–∞2 = fs2[1].toUpperCase();

    // Fuel trims
    const stft1 = T.match(/\b(SHRTFT1|STFT1)\s*`\(?%?\)`?[:\s]*(-?\d{1,3}(?:\.\d+)?)/i);
    if (stft1) out.STFT1 = Number(stft1[2]);
    const stft2 = T.match(/\b(SHRTFT2|STFT2)\s*`\(?%?\)`?[:\s]*(-?\d{1,3}(?:\.\d+)?)/i);
    if (stft2) out.STFT2 = Number(stft2[2]);
    const ltft1 = T.match(/\b(LONGFT1|LTFT1)\s*`\(?%?\)`?[:\s]*(-?\d{1,3}(?:\.\d+)?)/i);
    if (ltft1) out.LTFT1 = Number(ltft1[2]);
    const ltft2 = T.match(/\b(LONGFT2|LTFT2)\s*`\(?%?\)`?[:\s]*(-?\d{1,3}(?:\.\d+)?)/i);
    if (ltft2) out.LTFT2 = Number(ltft2[2]);

    // O2 sensors (global matchAll)
    const o2s = [...T.matchAll(/\bO2.*?(B\d).*?(S\d).*?[:\s]*([0-1](?:\.\d{1,3})?)V/gi)];
    o2s.forEach(m => { out[`O2_${m[1]}${m[2]}_V`] = Number(m[3]); });

    // AFR / Lambda
    const afr = T.match(/\b(AFR|Lambda)\b[:\s]*(-?\d{1,2}\.\d{1,3})/i);
    if (afr) out.AFR = Number(afr[2]);

    // Voltage
    const volt = T.match(/\b(Battery|Voltage)\b[:\s]*([0-9]{1,2}\.?[0-9])\s?V\b/i);
    if (volt) out.–ù–∞–ø—Ä—É–≥–∞–ê–ö–ë = Number(volt[2]);

    // Speed
    const spd = T.match(/\b(Speed|VSS)\b[:\s]*(-?\d{1,3})\s?(km\/h|mph)?/i);
    if (spd) { out.–®–≤–∏–¥–∫—ñ—Å—Ç—å = Number(spd[2]); out.–û–¥–∏–Ω–∏—Ü—ñ–®–≤–∏–¥–∫–æ—Å—Ç—ñ = spd[3] || 'km/h'; }

    // I/M Readiness (global)
    const imPairs = [...T.matchAll(/\b(Misfire Monitor|Fuel System Mon|Catalyst Mon|Evap System Mon|O2 Sensor Mon|O2 Sensor Htr|EGR System)\b[:\s]*(OK|INC|NA|OFF|ON)\b/gi)];
    if (imPairs.length) out.IMReadiness = imPairs.map(m => ({ name: m[1], status: m[2].toUpperCase() }));

    // Mode6 (try to extract)
    const testVal = T.match(/\b[Test|–¢–µ—Å—Ç][\s:]*value\b[:\s]*([-\d\.]+)/i) || T.match(/\bTest value\b[:\s]*([-\d\.]+)/i);
    const minLim  = T.match(/\bMin\s*Limit\b[:\s]*([-\d\.]+)/i);
    const maxLim  = T.match(/\bMax\s*Limit\b[:\s]*([-\d\.]+)/i);
    const status  = T.match(/\bStatus\b[:\s]*(Fail|Pass|OK|FAIL)/i);
    if (testVal || minLim || maxLim || status) {
      out.Mode6 = {
        testValue: testVal ? String(testVal[1]) : null,
        min: minLim ? String(minLim[1]) : null,
        max: maxLim ? String(maxLim[1]) : null,
        status: status ? String(status[1]).toUpperCase() : null
      };
    }

    // Component tests
    if (/Evaporative system leak test/i.test(T)) {
      out.ComponentTest = "EVAP Leak Test";
      const st = T.match(/\b(Pass|Fail)\b/i);
      if (st) out.ComponentStatus = st[1].toUpperCase();
    }
    if (/EGR/i.test(T) && /Component test/i.test(T)) {
      out.ComponentTest = (out.ComponentTest ? out.ComponentTest + ' + ' : '') + 'EGR Test';
    }

    // MIL
    const mil = T.match(/\b(MIL|Check\s*Engine)\b.*\b(ON|OFF)\b/i);
    if (mil) out.–ú–Ü–õ = mil[2].toUpperCase();

    // example placeholder for async fetch of DTC description
    if (out.–ö–æ–¥–∏–ü–æ–º–∏–ª–æ–∫ && out.–ö–æ–¥–∏–ü–æ–º–∏–ª–æ–∫.length) {
      // leave hook for future async enrichment
    }

    return out;
  }

  /* ==================== Sanitizer & helpers ==================== */
  function sanitizeParsed(parsed) {
    const out = {};
    for (const [k, v] of Object.entries(parsed || {})) {
      if (k === 'OCRText') { out[k] = String(v || ''); continue; }
      if (v == null) { out[k] = v; continue; }
      if (typeof v === 'string' || typeof v === 'number' || typeof v === 'boolean') {
        out[k] = v;
      } else if (Array.isArray(v)) {
        out[k] = v.map(item => (typeof item === 'object' ? safeObject(item) : item));
      } else if (typeof v === 'object') {
        out[k] = safeObject(v);
      } else {
        out[k] = String(v);
      }
    }
    return out;
  }
  function safeObject(obj) {
    const res = {};
    for (const [kk, vv] of Object.entries(obj || {})) {
      if (vv == null) res[kk] = vv;
      else if (typeof vv === 'string' || typeof vv === 'number' || typeof vv === 'boolean') res[kk] = vv;
      else res[kk] = String(vv);
    }
    return res;
  }

  /* ==================== renderKV (—É–Ω—ñ–≤–µ—Ä—Å–∞–ª—å–Ω–∏–π) ==================== */
  function escapeHtml(s) {
    return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
  }

  function renderKV(obj) {
    const kvEl = document.getElementById('kv');
    if (!kvEl) return;
    kvEl.innerHTML = '';

    const addRow = (key, contentHtml) => {
      const row = document.createElement('div');
      row.className = 'kv-row';
      row.innerHTML = `<div class="kv-key">${escapeHtml(key)}</div><div class="kv-value">${contentHtml}</div>`;
      kvEl.appendChild(row);
    };

    if (!obj || !Object.keys(obj).length) {
      addRow('–°—Ç–∞—Ç—É—Å', `<span class="badge">–ù–µ–º–∞—î —Ä–æ–∑–ø—ñ–∑–Ω–∞–Ω–∏—Ö –ø–æ–ª—ñ–≤</span>`);
      return;
    }

    for (const [k, v] of Object.entries(obj)) {
      if (k === 'OCRText') continue;
      if (v && typeof v === 'object' && !Array.isArray(v)) {
        const sub = Object.entries(v).map(([kk, vv]) => `${escapeHtml(kk)}: ${escapeHtml(String(vv))}`).join(', ');
        addRow(k, `<span class="badge">${sub}</span>`);
      } else if (Array.isArray(v)) {
        if (v.length && typeof v[0] === 'object') {
          const items = v.map(item => Object.entries(item).map(([kk, vv]) => `${escapeHtml(kk)}: ${escapeHtml(String(vv))}`).join(', ')).join(' | ');
          addRow(k, `<span class="badge">${items}</span>`);
        } else {
          addRow(k, `<span class="badge">${escapeHtml((v||[]).join(', '))}</span>`);
        }
      } else {
        addRow(k, `<span class="badge">${escapeHtml(String(v))}</span>`);
      }
    }

    if (obj.OCRText) {
      const details = document.createElement('details');
      details.className = 'debug';
      const sum = document.createElement('summary');
      sum.textContent = '–ü–æ–∫–∞–∑–∞—Ç–∏ —Å–∏—Ä–∏–π OCR‚Äë—Ç–µ–∫—Å—Ç';
      const pre = document.createElement('pre');
      pre.textContent = obj.OCRText;
      details.appendChild(sum);
      details.appendChild(pre);
      kvEl.appendChild(details);
    }
  }

  /* ==================== getTips (–ø—Ä–æ—Å—Ç—ñ –ø–æ—Ä–∞–¥–∏, –º–æ–∂–Ω–∞ —Ä–æ–∑—à–∏—Ä–∏—Ç–∏) ==================== */
  function getTips(parsed) {
    const tips = [];
    if (!parsed) return ['–ü—Ä–æ–±–ª–µ–º –Ω–µ –≤–∏—è–≤–ª–µ–Ω–æ –∞–±–æ –ø–æ—Ç—Ä—ñ–±–Ω—ñ –¥–æ–¥–∞—Ç–∫–æ–≤—ñ –¥–∞–Ω—ñ.'];

    if (parsed.–ö–æ–¥–∏–ü–æ–º–∏–ª–æ–∫ && parsed.–ö–æ–¥–∏–ü–æ–º–∏–ª–æ–∫.length) {
      tips.push(`–ó–Ω–∞–π–¥–µ–Ω–æ –∫–æ–¥–∏ –ø–æ–º–∏–ª–æ–∫: ${parsed.–ö–æ–¥–∏–ü–æ–º–∏–ª–æ–∫.join(', ')}`);
    }
    if (parsed.Mode6 && parsed.Mode6.status && parsed.Mode6.status.toUpperCase() === 'FAIL') {
      tips.push('Mode 6: —Ç–µ—Å—Ç –Ω–µ –ø—Ä–æ–π–¥–µ–Ω–æ. –ü–µ—Ä–µ–≥–ª—è–Ω—å—Ç–µ Test/Min/Max, —ñ–¥–µ–Ω—Ç–∏—Ñ—ñ–∫—É–π—Ç–µ —Å–µ–Ω—Å–æ—Ä/—Å—É–±—Ç–µ—Å—Ç.');
    }
    if (!parsed || (Object.keys(parsed).length === 1 && parsed.OCRText)) {
      tips.push('OCR –Ω–µ –∑–Ω–∞–π—à–æ–≤ —Å—Ç—Ä—É–∫—Ç—É—Ä–æ–≤–∞–Ω–∏—Ö –¥–∞–Ω–∏—Ö. –°–ø—Ä–æ–±—É–π—Ç–µ —ñ–Ω—à–µ —Ñ–æ—Ç–æ –∞–±–æ –ø–æ–∫—Ä–∞—â–∏—Ç–∏ –∫–æ–Ω—Ç—Ä–∞—Å—Ç.');
    }
    if (!tips.length) tips.push('–ü—Ä–æ–±–ª–µ–º –Ω–µ –≤–∏—è–≤–ª–µ–Ω–æ –∞–±–æ –ø–æ—Ç—Ä—ñ–±–Ω—ñ –¥–æ–¥–∞—Ç–∫–æ–≤—ñ –¥–∞–Ω—ñ.');
    return tips;
  }

  /* ==================== renderResult (–≤–∏–∫–ª–∏–∫–∞—î renderKV + –ø–æ–∫–∞–∑ –ø–æ—Ä–∞–¥) ==================== */
  function renderResult(parsed, tips) {
    const statusTextEl = document.getElementById('statusText');
    try {
      const safe = sanitizeParsed(parsed);
      renderKV(safe);
      statusTextEl.textContent = (tips && tips.length) ? tips.join(' ‚Ä¢ ') : '–ì–æ—Ç–æ–≤–æ';
    } catch (e) {
      console.error('renderResult error', e);
      statusTextEl.textContent = '–ü–æ–º–∏–ª–∫–∞ –≤—ñ–¥–æ–±—Ä–∞–∂–µ–Ω–Ω—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç—É';
    }
  }

  /* ==================== Camera / Gallery / Crop / OCR flow ==================== */
  (function initFlow(){
    // DOM
    const openCameraBtn = document.getElementById('openCameraBtn');
    const captureBtn = document.getElementById('captureBtn');
    const stopCameraBtn = document.getElementById('stopCameraBtn');
    const video = document.getElementById('video');
    const fileInput = document.getElementById('fileInput');
    const pickPhotoBtn = document.getElementById('pickPhotoBtn');
    const cropBtn = document.getElementById('cropBtn');
    const canvas = document.getElementById('canvas');
    const statusText = document.getElementById('statusText');

    let stream = null;
    let cropper = null;
    let tempImgEl = null;

    openCameraBtn.addEventListener('click', async () => {
      try {
        if (stream) stopCamera();
        stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false });
        video.srcObject = stream;
        video.classList.remove('hidden');
        captureBtn.classList.remove('hidden');
        stopCameraBtn.classList.remove('hidden');
        statusText.textContent = '–ö–∞–º–µ—Ä–∞ —É–≤—ñ–º–∫–Ω–µ–Ω–∞. –ù–∞–≤–µ–¥–∏ –Ω–∞ –µ–∫—Ä–∞–Ω —Å–∫–∞–Ω–µ—Ä–∞ —ñ –Ω–∞—Ç–∏—Å–Ω–∏ "–ó–∞—Ö–æ–ø–∏—Ç–∏ –∫–∞–¥—Ä".';
      } catch (err) {
        console.error('camera error', err);
        statusText.textContent = '–ù–µ –≤–¥–∞–ª–æ—Å—è –≤—ñ–¥–∫—Ä–∏—Ç–∏ –∫–∞–º–µ—Ä—É: ' + (err.message || err);
      }
    });

    stopCameraBtn.addEventListener('click', () => { stopCamera(); statusText.textContent = '–ö–∞–º–µ—Ä–∞ –∑—É–ø–∏–Ω–µ–Ω–∞'; });

    function stopCamera() {
      if (!stream) return;
      stream.getTracks().forEach(t => t.stop());
      stream = null;
      video.classList.add('hidden');
      captureBtn.classList.add('hidden');
      stopCameraBtn.classList.add('hidden');
    }

    captureBtn.addEventListener('click', () => {
      if (!video || video.readyState < 2) {
        statusText.textContent = '–ö–∞–¥—Ä –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∏–π, –∑–∞—á–µ–∫–∞–π—Ç–µ –∫–∞–º–µ—Ä—É.';
        return;
      }
      // capture to canvas
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      // stop camera
      stopCamera();
      // open cropper flow
      const dataUrl = canvas.toDataURL('image/png');
      startCropperFromDataUrl(dataUrl);
    });

    pickPhotoBtn.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      const url = URL.createObjectURL(file);
      startCropperFromDataUrl(url);
    });

    function startCropperFromDataUrl(url) {
      // cleanup existing
      if (cropper) { cropper.destroy(); cropper = null; }
      if (tempImgEl) { tempImgEl.remove(); tempImgEl = null; }

      tempImgEl = document.createElement('img');
      tempImgEl.src = url;
      tempImgEl.style.maxWidth = '90vw';
      tempImgEl.style.maxHeight = '70vh';
      tempImgEl.style.display = 'block';
      document.body.appendChild(tempImgEl);

      tempImgEl.onload = () => {
        cropper = new Cropper(tempImgEl, {
          aspectRatio: NaN,
          viewMode: 1,
          autoCropArea: 0.9,
          movable: true,
          zoomable: true,
          responsive: true
        });
        cropBtn.classList.remove('hidden');
        statusText.textContent = '–í–∏–¥—ñ–ª—ñ—Ç—å –µ–∫—Ä–∞–Ω —Å–∫–∞–Ω–µ—Ä–∞ —ñ –Ω–∞—Ç–∏—Å–Ω—ñ—Ç—å "–û–±—Ä—ñ–∑–∞—Ç–∏".';
      };
    }

    cropBtn.addEventListener('click', async () => {
      if (!cropper) return;
      statusText.textContent = '–û–±—Ä—ñ–∑–∫–∞ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è...';
      const croppedCanvas = cropper.getCroppedCanvas({ imageSmoothingEnabled: true, imageSmoothingQuality: 'high' });
      // show result
      canvas.width = croppedCanvas.width;
      canvas.height = croppedCanvas.height;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(croppedCanvas, 0, 0);
      canvas.classList.remove('hidden');

      // cleanup cropper
      cropper.destroy();
      cropper = null;
      if (tempImgEl) { tempImgEl.remove(); tempImgEl = null; }
      cropBtn.classList.add('hidden');

      // optional: pre-process to increase contrast (simple)
      try {
        const imageData = ctx.getImageData(0,0,canvas.width,canvas.height);
        for (let i=0;i<imageData.data.length;i+=4){
          const r=imageData.data[i], g=imageData.data[i+1], b=imageData.data[i+2];
          let gray = 0.299*r + 0.587*g + 0.114*b;
          gray = Math.min(255, Math.max(0, (gray-128)*1.5 + 128));
          imageData.data[i]=imageData.data[i+1]=imageData.data[i+2]=gray;
        }
        ctx.putImageData(imageData,0,0);
      } catch(e){ console.warn('preprocess skipped',e); }

      statusText.textContent = 'üîé –í–∏–∫–æ–Ω—É—î—Ç—å—Å—è OCR...';
      try {
        const blob = await new Promise(res => croppedCanvas.toBlob(res, 'image/png'));
        const { data } = await Tesseract.recognize(blob, 'eng', { logger: m => console.log('Tesseract', m) });
        const text = data?.text ?? '';
        statusText.textContent = '‚úÖ OCR –∑–∞–≤–µ—Ä—à–µ–Ω–æ';
        console.log('OCR text:', text);

        const parsed = await parseV519(text);
        const safeParsed = sanitizeParsed(parsed);
        const tips = getTips(safeParsed);
        renderResult(safeParsed, tips);
      } catch (err) {
        console.error('OCR error', err);
        statusText.textContent = '‚ùå –ü–æ–º–∏–ª–∫–∞ OCR: ' + (err.message || err);
      }
    });
  })();
  </script>
</body>
</html>